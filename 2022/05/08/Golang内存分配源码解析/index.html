
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Golang内存分配源码解析 | iBlog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="luckymrwang">
    

    
    <meta name="description" content="Golang内存分配整体架构">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang内存分配源码解析">
<meta property="og:url" content="https://luckymrwang.github.io/2022/05/08/Golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="iBlog">
<meta property="og:description" content="Golang内存分配整体架构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://luckymrwang.github.io/images/golang-memory1.jpg">
<meta property="og:image" content="https://luckymrwang.github.io/images/golang-memory2.jpg">
<meta property="og:image" content="https://luckymrwang.github.io/images/golang-memory3.jpg">
<meta property="og:image" content="https://luckymrwang.github.io/images/golang-memory4.jpg">
<meta property="article:published_time" content="2022-05-08T02:09:01.000Z">
<meta property="article:modified_time" content="2025-06-19T10:22:16.192Z">
<meta property="article:author" content="luckymrwang">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luckymrwang.github.io/images/golang-memory1.jpg">

    
    <link rel="alternative" href="/atom.xml" title="iBlog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">

    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2966365318189151"
     crossorigin="anonymous"></script>
<meta name="generator" content="Hexo 7.3.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="iBlog" title="iBlog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="iBlog">iBlog</a></h1>
				<h2 class="blog-motto">Write down what I think.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">文章列表</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:luckymrwang.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/05/08/Golang内存分配源码解析/" title="Golang内存分配源码解析" itemprop="url">Golang内存分配源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="luckymrwang" target="_blank" itemprop="author">luckymrwang</a>
		
  <p class="article-time">
    <time datetime="2022-05-08T02:09:01.000Z" itemprop="datePublished"> 发表于 2022-05-08</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">Golang内存分配整体架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#makeslice"><span class="toc-number">2.</span> <span class="toc-text">makeslice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96-mallocinit"><span class="toc-number">3.</span> <span class="toc-text">内存初始化-mallocinit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mcentral%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">mcentral初始化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mallocgc-%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7"><span class="toc-number">3.2.</span> <span class="toc-text">mallocgc-内存申请</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">什么是内存对齐？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runtime-nextFreeFast-%E5%B0%9D%E8%AF%95%E4%BB%8E%E7%BC%93%E5%AD%98%E4%B8%AD%E5%BF%AB%E9%80%9F%E5%88%86%E9%85%8D"><span class="toc-number">3.4.</span> <span class="toc-text">runtime.nextFreeFast-尝试从缓存中快速分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mcache-nextFree-%E7%94%B3%E8%AF%B7%E6%96%B0%E7%9A%84span"><span class="toc-number">3.5.</span> <span class="toc-text">mcache.nextFree-申请新的span</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mcache-refill-%E5%90%91mcentral%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98"><span class="toc-number">3.6.</span> <span class="toc-text">mcache.refill-向mcentral申请内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mcentral-cacheSpan-%E5%90%91mcentral%E7%94%B3%E8%AF%B7span"><span class="toc-number">3.7.</span> <span class="toc-text">mcentral.cacheSpan-向mcentral申请span</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mcentral-grow-%E5%90%91heap%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98"><span class="toc-number">3.8.</span> <span class="toc-text">mcentral.grow-向heap申请内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mcache-allocLarge-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D"><span class="toc-number">3.9.</span> <span class="toc-text">mcache.allocLarge-大对象分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mheap%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B"><span class="toc-number">3.10.</span> <span class="toc-text">mheap分配流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#alloc"><span class="toc-number">3.10.1.</span> <span class="toc-text">alloc</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#allocSpan"><span class="toc-number">3.11.</span> <span class="toc-text">allocSpan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#grow-%E5%90%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98"><span class="toc-number">3.12.</span> <span class="toc-text">grow-向操作系统申请内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sysAlloc"><span class="toc-number">3.13.</span> <span class="toc-text">sysAlloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sysReserve-mmap%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.14.</span> <span class="toc-text">sysReserve-mmap系统调用</span></a></li></ol></li></ol>
		
		</div>
		
		<h3 id="Golang内存分配整体架构"><a href="#Golang内存分配整体架构" class="headerlink" title="Golang内存分配整体架构"></a>Golang内存分配整体架构</h3><p><img src="/images/golang-memory1.jpg" alt="image"></p>
<span id="more"></span>
<p>简化后：</p>
<p><img src="/images/golang-memory2.jpg" alt="image"></p>
<h3 id="makeslice"><a href="#makeslice" class="headerlink" title="makeslice"></a>makeslice</h3><p>以创建切片为例，在64位操作系统上，会调用<code>makeslice64()</code>，最终都会去调用<code>makeslice()</code>去进行最终的创建动作，先计算是否内存溢出或越界，再通过调用<code>mallocgc</code>分配内存给<code>slice</code>，源码在 runtime&#x2F;slice.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	mem, overflow := math.MulUintptr(et.size, <span class="type">uintptr</span>(<span class="built_in">cap</span>))	</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;	<span class="comment">//判断内存是否溢出或者需要的内存大于系统可以给的最大内存</span></span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> Produce a &#x27;len out of range&#x27; error instead of a</span></span><br><span class="line">		<span class="comment">// &#x27;cap out of range&#x27; error when someone does make([]T, bignumber).</span></span><br><span class="line">		<span class="comment">// &#x27;cap out of range&#x27; is true too, but since the cap is only being</span></span><br><span class="line">		<span class="comment">// supplied implicitly, saying len is clearer.</span></span><br><span class="line">		<span class="comment">// See golang.org/issue/4085.</span></span><br><span class="line">		mem, overflow := math.MulUintptr(et.size, <span class="type">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line">		<span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">			panicmakeslicelen()	<span class="comment">//len越界</span></span><br><span class="line">		&#125;</span><br><span class="line">		panicmakeslicecap()<span class="comment">//cap越界</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)<span class="comment">//申请内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice64</span><span class="params">(et *_type, len64, cap64 <span class="type">int64</span>)</span></span> unsafe.Pointer &#123;<span class="comment">//64位添加保护机制，判断申请的大小是否超出或小于阈值</span></span><br><span class="line">	<span class="built_in">len</span> := <span class="type">int</span>(len64)</span><br><span class="line">	<span class="keyword">if</span> <span class="type">int64</span>(<span class="built_in">len</span>) != len64 &#123;</span><br><span class="line">		panicmakeslicelen()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cap</span> := <span class="type">int</span>(cap64)</span><br><span class="line">	<span class="keyword">if</span> <span class="type">int64</span>(<span class="built_in">cap</span>) != cap64 &#123;</span><br><span class="line">		panicmakeslicecap()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> makeslice(et, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存初始化-mallocinit"><a href="#内存初始化-mallocinit" class="headerlink" title="内存初始化-mallocinit"></a>内存初始化-mallocinit</h3><ul>
<li>检查系统&#x2F;硬件信息</li>
<li>计算预留空间大小</li>
<li>尝试预留地址</li>
<li>初始化mheap中的一部分变量</li>
<li>其他部分初始化，67个mcentral在这里初始化</li>
</ul>
<h4 id="mcentral初始化："><a href="#mcentral初始化：" class="headerlink" title="mcentral初始化："></a>mcentral初始化：</h4><ul>
<li>设置自己的级别</li>
<li>将两个mspanList初始化</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> class_to_size[_TinySizeClass] != _TinySize &#123; <span class="comment">// 校tiny分配大小</span></span><br><span class="line">		throw(<span class="string">&quot;bad TinySizeClass&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	testdefersizes()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> heapArenaBitmapBytes&amp;(heapArenaBitmapBytes<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// heapBits expects modular arithmetic on bitmap</span></span><br><span class="line">		<span class="comment">// addresses to work.</span></span><br><span class="line">		throw(<span class="string">&quot;heapArenaBitmapBytes not a power of 2&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy class sizes out for statistics table.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> class_to_size &#123;</span><br><span class="line">		memstats.by_size[i].size = <span class="type">uint32</span>(class_to_size[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check physPageSize.</span></span><br><span class="line">	<span class="keyword">if</span> physPageSize == <span class="number">0</span> &#123; <span class="comment">// 检查物理页大小</span></span><br><span class="line">		<span class="comment">// The OS init code failed to fetch the physical page size.</span></span><br><span class="line">		throw(<span class="string">&quot;failed to get system page size&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> physPageSize &gt; maxPhysPageSize &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;system page size (&quot;</span>, physPageSize, <span class="string">&quot;) is larger than maximum page size (&quot;</span>, maxPhysPageSize, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;bad system page size&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> physPageSize &lt; minPhysPageSize &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;system page size (&quot;</span>, physPageSize, <span class="string">&quot;) is smaller than minimum page size (&quot;</span>, minPhysPageSize, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;bad system page size&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> physPageSize&amp;(physPageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;system page size (&quot;</span>, physPageSize, <span class="string">&quot;) must be a power of 2\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;bad system page size&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> physHugePageSize&amp;(physHugePageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;system huge page size (&quot;</span>, physHugePageSize, <span class="string">&quot;) must be a power of 2\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;bad system huge page size&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> physHugePageSize &gt; maxPhysHugePageSize &#123;</span><br><span class="line">		<span class="comment">// physHugePageSize is greater than the maximum supported huge page size.</span></span><br><span class="line">		<span class="comment">// Don&#x27;t throw here, like in the other cases, since a system configured</span></span><br><span class="line">		<span class="comment">// in this way isn&#x27;t wrong, we just don&#x27;t have the code to support them.</span></span><br><span class="line">		<span class="comment">// Instead, silently set the huge page size to zero.</span></span><br><span class="line">		physHugePageSize = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> physHugePageSize != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Since physHugePageSize is a power of 2, it suffices to increase</span></span><br><span class="line">		<span class="comment">// physHugePageShift until 1&lt;&lt;physHugePageShift == physHugePageSize.</span></span><br><span class="line">		<span class="keyword">for</span> <span class="number">1</span>&lt;&lt;physHugePageShift != physHugePageSize &#123;</span><br><span class="line">			physHugePageShift++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> pagesPerArena%pagesPerSpanRoot != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;pagesPerArena (&quot;</span>, pagesPerArena, <span class="string">&quot;) is not divisible by pagesPerSpanRoot (&quot;</span>, pagesPerSpanRoot, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;bad pagesPerSpanRoot&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> pagesPerArena%pagesPerReclaimerChunk != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;pagesPerArena (&quot;</span>, pagesPerArena, <span class="string">&quot;) is not divisible by pagesPerReclaimerChunk (&quot;</span>, pagesPerReclaimerChunk, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;bad pagesPerReclaimerChunk&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the heap.</span></span><br><span class="line">	mheap_.init() <span class="comment">// 初始化堆内存</span></span><br><span class="line">	mcache0 = allocmcache()</span><br><span class="line">	lockInit(&amp;gcBitsArenas.lock, lockRankGcBitsArenas)</span><br><span class="line">	lockInit(&amp;proflock, lockRankProf)</span><br><span class="line">	lockInit(&amp;globalAlloc.mutex, lockRankGlobalAlloc)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create initial arena growth hints.</span></span><br><span class="line">  <span class="comment">// 初始化内存分配 arena，arena 是一段连续的内存，负责数据的内存分配。</span></span><br><span class="line">	<span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123; <span class="comment">// 64位不同系统上进行地址的划分</span></span><br><span class="line">		<span class="comment">// On a 64-bit machine, we pick the following hints</span></span><br><span class="line">		<span class="comment">// because:</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 1. Starting from the middle of the address space</span></span><br><span class="line">		<span class="comment">// makes it easier to grow out a contiguous range</span></span><br><span class="line">		<span class="comment">// without running in to some other mapping.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 2. This makes Go heap addresses more easily</span></span><br><span class="line">		<span class="comment">// recognizable when debugging.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 3. Stack scanning in gccgo is still conservative,</span></span><br><span class="line">		<span class="comment">// so it&#x27;s important that addresses be distinguishable</span></span><br><span class="line">		<span class="comment">// from other data.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Starting at 0x00c0 means that the valid memory addresses</span></span><br><span class="line">		<span class="comment">// will begin 0x00c0, 0x00c1, ...</span></span><br><span class="line">		<span class="comment">// In little-endian, that&#x27;s c0 00, c1 00, ... None of those are valid</span></span><br><span class="line">		<span class="comment">// UTF-8 sequences, and they are otherwise as far away from</span></span><br><span class="line">		<span class="comment">// ff (likely a common byte) as possible. If that fails, we try other 0xXXc0</span></span><br><span class="line">		<span class="comment">// addresses. An earlier attempt to use 0x11f8 caused out of memory errors</span></span><br><span class="line">		<span class="comment">// on OS X during thread allocations.  0x00c0 causes conflicts with</span></span><br><span class="line">		<span class="comment">// AddressSanitizer which reserves all memory up to 0x0100.</span></span><br><span class="line">		<span class="comment">// These choices reduce the odds of a conservative garbage collector</span></span><br><span class="line">		<span class="comment">// not collecting memory because some non-pointer block of memory</span></span><br><span class="line">		<span class="comment">// had a bit pattern that matched a memory address.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// However, on arm64, we ignore all this advice above and slam the</span></span><br><span class="line">		<span class="comment">// allocation at 0x40 &lt;&lt; 32 because when using 4k pages with 3-level</span></span><br><span class="line">		<span class="comment">// translation buffers, the user address space is limited to 39 bits</span></span><br><span class="line">		<span class="comment">// On ios/arm64, the address space is even smaller.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// On AIX, mmaps starts at 0x0A00000000000000 for 64-bit.</span></span><br><span class="line">		<span class="comment">// processes.</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0x7f</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">			<span class="keyword">var</span> p <span class="type">uintptr</span></span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> raceenabled:</span><br><span class="line">				<span class="comment">// The TSAN runtime requires the heap</span></span><br><span class="line">				<span class="comment">// to be in the range [0x00c000000000,</span></span><br><span class="line">				<span class="comment">// 0x00e000000000).</span></span><br><span class="line">				p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">32</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">				<span class="keyword">if</span> p &gt;= uintptrMask&amp;<span class="number">0x00e000000000</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> GOARCH == <span class="string">&quot;arm64&quot;</span> &amp;&amp; GOOS == <span class="string">&quot;ios&quot;</span>:</span><br><span class="line">				p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0013</span>&lt;&lt;<span class="number">28</span>)</span><br><span class="line">			<span class="keyword">case</span> GOARCH == <span class="string">&quot;arm64&quot;</span>:</span><br><span class="line">				p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0040</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">			<span class="keyword">case</span> GOOS == <span class="string">&quot;aix&quot;</span>:</span><br><span class="line">				<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="comment">// We don&#x27;t use addresses directly after 0x0A00000000000000</span></span><br><span class="line">					<span class="comment">// to avoid collisions with others mmaps done by non-go programs.</span></span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0xa0</span>&lt;&lt;<span class="number">52</span>)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				p = <span class="type">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())</span><br><span class="line">			hint.addr = p</span><br><span class="line">			hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//32 位</span></span><br><span class="line">		<span class="comment">// On a 32-bit machine, we&#x27;re much more concerned</span></span><br><span class="line">		<span class="comment">// about keeping the usable heap contiguous.</span></span><br><span class="line">		<span class="comment">// Hence:</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 1. We reserve space for all heapArenas up front so</span></span><br><span class="line">		<span class="comment">// they don&#x27;t get interleaved with the heap. They&#x27;re</span></span><br><span class="line">		<span class="comment">// ~258MB, so this isn&#x27;t too bad. (We could reserve a</span></span><br><span class="line">		<span class="comment">// smaller amount of space up front if this is a</span></span><br><span class="line">		<span class="comment">// problem.)</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 2. We hint the heap to start right above the end of</span></span><br><span class="line">		<span class="comment">// the binary so we have the best chance of keeping it</span></span><br><span class="line">		<span class="comment">// contiguous.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 3. We try to stake out a reasonably large initial // 栈预留</span></span><br><span class="line">		<span class="comment">// heap reservation.</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> arenaMetaSize = (<span class="number">1</span> &lt;&lt; arenaBits) * unsafe.Sizeof(heapArena&#123;&#125;)</span><br><span class="line">		meta := <span class="type">uintptr</span>(sysReserve(<span class="literal">nil</span>, arenaMetaSize))</span><br><span class="line">		<span class="keyword">if</span> meta != <span class="number">0</span> &#123;</span><br><span class="line">			mheap_.heapArenaAlloc.init(meta, arenaMetaSize)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 我们想要让 arena 区域从低地址开始，但是我们的代码可能和 C 代码进行链接，</span></span><br><span class="line">        <span class="comment">// 全局的构造器可能已经调用过 malloc，并且调整过进程的 brk 位置。</span></span><br><span class="line">        <span class="comment">// 所以需要查询一次 brk，以避免将我们的 arena 区域覆盖掉 brk 位置，</span></span><br><span class="line">        <span class="comment">// 这会导致 kernel 把 arena 放在其它地方，比如放在高地址。</span></span><br><span class="line">		procBrk := sbrk0() </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Linux系统分配用户内存的API是brk()。它的作用就是改变数据段的末尾位置，也就是改变进程的brk的位置。</span></span><br><span class="line">    <span class="comment">//进程的brk之前的内存，就是可以使用的堆内存。移动brk的位置，就可以分配内存。操作系统的API就是这么简单直接。</span></span><br><span class="line">    <span class="comment">//brk()函数，是Linux的一个系统调用。在x86_64平台上，它的调用号是12。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// If we ask for the end of the data segment but the</span></span><br><span class="line">		<span class="comment">// operating system requires a little more space</span></span><br><span class="line">		<span class="comment">// before we can start allocating, it will give out a</span></span><br><span class="line">		<span class="comment">// slightly higher pointer. Except QEMU, which is</span></span><br><span class="line">		<span class="comment">// buggy, as usual: it won&#x27;t adjust the pointer</span></span><br><span class="line">		<span class="comment">// upward. So adjust it upward a little bit ourselves:</span></span><br><span class="line">		<span class="comment">// 1/4 MB to get away from the running binary image.</span></span><br><span class="line">		p := firstmoduledata.end</span><br><span class="line">		<span class="keyword">if</span> p &lt; procBrk &#123;</span><br><span class="line">			p = procBrk</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> mheap_.heapArenaAlloc.next &lt;= p &amp;&amp; p &lt; mheap_.heapArenaAlloc.end &#123;</span><br><span class="line">			p = mheap_.heapArenaAlloc.end</span><br><span class="line">		&#125;</span><br><span class="line">		p = alignUp(p+(<span class="number">256</span>&lt;&lt;<span class="number">10</span>), heapArenaBytes)</span><br><span class="line">		<span class="comment">// Because we&#x27;re worried about fragmentation on</span></span><br><span class="line">		<span class="comment">// 32-bit, we try to make a large initial reservation.</span></span><br><span class="line">    <span class="comment">//// 如果分配失败，那么尝试用更小一些的 arena 区域。</span></span><br><span class="line">        <span class="comment">// 对于像 Android L 这样的系统是需要的，因为我们和 ART 更新同一个进程，</span></span><br><span class="line">        <span class="comment">// 其会更激进地保留内存。</span></span><br><span class="line">        <span class="comment">// 最差的情况下，会退化为 0 大小的初始 arena</span></span><br><span class="line">        <span class="comment">// 这种情况下希望之后紧跟着的内存保留操作能够成功。</span></span><br><span class="line">    </span><br><span class="line">		arenaSizes := []<span class="type">uintptr</span>&#123;</span><br><span class="line">			<span class="number">512</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">			<span class="number">256</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">			<span class="number">128</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, arenaSize := <span class="keyword">range</span> arenaSizes &#123;</span><br><span class="line">      <span class="comment">// 申请初始化对齐内存</span></span><br><span class="line">			a, size := sysReserveAligned(unsafe.Pointer(p), arenaSize, heapArenaBytes)</span><br><span class="line">			<span class="keyword">if</span> a != <span class="literal">nil</span> &#123;</span><br><span class="line">				mheap_.arena.init(<span class="type">uintptr</span>(a), size) <span class="comment">// 初始化arena</span></span><br><span class="line">				p = mheap_.arena.end <span class="comment">// For hint below</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())</span><br><span class="line">		hint.addr = p</span><br><span class="line">		hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mcache</code>的初始化在<code>func procresize(nprocs int32)</code>中，<code>procresize</code>也在<code>schedinit()</code>中调用，顺序在<code>mallocinit()</code>之后，所以说也就是说<code>mcentral</code>先初始化，然后是<code>mcache</code>，它在初始化P的时候初始化具体代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocmcache</span><span class="params">()</span></span> *mcache &#123;</span><br><span class="line">	<span class="keyword">var</span> c *mcache</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		lock(&amp;mheap_.lock)</span><br><span class="line">		c = (*mcache)(mheap_.cachealloc.alloc())</span><br><span class="line">		c.flushGen = mheap_.sweepgen</span><br><span class="line">		unlock(&amp;mheap_.lock)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c.alloc &#123;</span><br><span class="line">		c.alloc[i] = &amp;emptymspan</span><br><span class="line">	&#125;</span><br><span class="line">	c.nextSample = nextSample()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个初始化后，管理结构、mheap、67个mcentral及每个goroutine的mcache都初始化完毕。接下来就是使用时，如何分配和管理内存。</p>
<h4 id="mallocgc-内存申请"><a href="#mallocgc-内存申请" class="headerlink" title="mallocgc-内存申请"></a>mallocgc-内存申请</h4><p>&#x2F;runtime&#x2F;malloc.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate an object of size bytes.</span></span><br><span class="line"><span class="comment">// Small objects are allocated from the per-P cache&#x27;s free lists.</span></span><br><span class="line"><span class="comment">// Large objects (&gt; 32 kB) are allocated straight from the heap.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="keyword">if</span> gcphase == _GCmarktermination &#123; <span class="comment">//判断是否正在GC，如果在GC，等待GC完后再拉起用户协程继续（stop the world）</span></span><br><span class="line">		throw(<span class="string">&quot;mallocgc called with gcphase == _GCmarktermination&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> size == <span class="number">0</span> &#123; <span class="comment">//zerobase:所有0字节的基地址（空指针）</span></span><br><span class="line">		<span class="keyword">return</span> unsafe.Pointer(&amp;zerobase)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debug.malloc &#123;</span><br><span class="line">		<span class="keyword">if</span> debug.sbrk != <span class="number">0</span> &#123; <span class="comment">//sbrk=1时会使用一个碎片回收器代替内存分配器和垃圾回收器。它从操作系统获取内存，并且永远也不会回收任何内存。用于调试，正常流程不会走这段</span></span><br><span class="line">			align := <span class="type">uintptr</span>(<span class="number">16</span>)</span><br><span class="line">			<span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;<span class="comment">//内存对齐</span></span><br><span class="line">				<span class="comment">// TODO(austin): This should be just</span></span><br><span class="line">				<span class="comment">//   align = uintptr(typ.align)</span></span><br><span class="line">				<span class="comment">// but that&#x27;s only 4 on 32-bit platforms,</span></span><br><span class="line">				<span class="comment">// even if there&#x27;s a uint64 field in typ (see #599).</span></span><br><span class="line">				<span class="comment">// This causes 64-bit atomic accesses to panic.</span></span><br><span class="line">				<span class="comment">// Hence, we use stricter alignment that matches</span></span><br><span class="line">				<span class="comment">// the normal allocator better.</span></span><br><span class="line">				<span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">					align = <span class="number">8</span></span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">					align = <span class="number">4</span></span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">					align = <span class="number">2</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					align = <span class="number">1</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> persistentalloc(size, align, &amp;memstats.other_sys)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> inittrace.active &amp;&amp; inittrace.id == getg().goid &#123; <span class="comment">//初始化trace的统计信息，trace信息就是在这加载的</span></span><br><span class="line">			<span class="comment">// Init functions are executed sequentially in a single Go routine.</span></span><br><span class="line">			inittrace.allocs += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// assistG is the G to charge for this allocation, or nil if</span></span><br><span class="line">	<span class="comment">// GC is not currently active.</span></span><br><span class="line">  <span class="comment">//为了保证用户程序分配内存的速度不会超出后台任务的标记速度，runtime引入了标记辅助技术，它遵循一条非常简单并且朴实的原则，分配多少内存就需要完成多少标记任务。每一个 Goroutine 都持有 gcAssistBytes 字段，这个字段存储了当前 Goroutine 辅助标记的对象字节数。在并发标记阶段期间，当 Goroutine 调用 runtime.mallocgc 分配新对象时，该函数会检查申请内存的 Goroutine 是否处于入不敷出的状态</span></span><br><span class="line">	<span class="keyword">var</span> assistG *g</span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Charge the current user G for this allocation.</span></span><br><span class="line">		assistG = getg()</span><br><span class="line">		<span class="keyword">if</span> assistG.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">			assistG = assistG.m.curg</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Charge the allocation against the G. We&#x27;ll account</span></span><br><span class="line">		<span class="comment">// for internal fragmentation at the end of mallocgc.</span></span><br><span class="line">		assistG.gcAssistBytes -= <span class="type">int64</span>(size)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> assistG.gcAssistBytes &lt; <span class="number">0</span> &#123; <span class="comment">//会按分配的大小判断需要协助GC完成多少工作</span></span><br><span class="line">			<span class="comment">// This G is in debt. Assist the GC to correct</span></span><br><span class="line">			<span class="comment">// this before allocating. This must happen</span></span><br><span class="line">			<span class="comment">// before disabling preemption.</span></span><br><span class="line">      <span class="comment">//申请内存时调用的 runtime.gcAssistAlloc 和扫描内存时调用的 runtime.gcFlushBgCredit 分别负责借债和还债，通过这套债务管理系统，保证 Goroutine 在正常运行的同时不会为垃圾收集造成太多的压力，保证在达到堆大小目标时完成标记阶段。</span></span><br><span class="line">			gcAssistAlloc(assistG)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set mp.mallocing to keep from being preempted by GC.</span></span><br><span class="line">	mp := acquirem() <span class="comment">//设置 mp.mallocing 以防止被 GC 抢占。（独占m）</span></span><br><span class="line">	<span class="keyword">if</span> mp.mallocing != <span class="number">0</span> &#123; <span class="comment">//如果m正在分配内存，则造成死锁</span></span><br><span class="line">		throw(<span class="string">&quot;malloc deadlock&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> mp.gsignal == getg() &#123;</span><br><span class="line">		throw(<span class="string">&quot;malloc during signal&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mp.mallocing = <span class="number">1</span> <span class="comment">//标记为正在分配内存</span></span><br><span class="line"></span><br><span class="line">	shouldhelpgc := <span class="literal">false</span></span><br><span class="line">	dataSize := size</span><br><span class="line">	c := getMCache() <span class="comment">//获取当前m的m mcache</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;mallocgc called without a P or outside bootstrapping&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> span *mspan</span><br><span class="line">	<span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">	noscan := typ == <span class="literal">nil</span> || typ.ptrdata == <span class="number">0</span> <span class="comment">//判断是否是指针类型</span></span><br><span class="line">	<span class="keyword">if</span> size &lt;= maxSmallSize &#123; <span class="comment">//小于等于32KB的对象申请内存</span></span><br><span class="line">		<span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123; <span class="comment">//非指针（值类型）&amp;&amp;小于16b的内存，使用tiny分配</span></span><br><span class="line">			<span class="comment">// Tiny allocator.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// Tiny allocator combines several tiny allocation requests</span></span><br><span class="line">			<span class="comment">// into a single memory block. The resulting memory block</span></span><br><span class="line">			<span class="comment">// is freed when all subobjects are unreachable. The subobjects</span></span><br><span class="line">			<span class="comment">// must be noscan (don&#x27;t have pointers), this ensures that</span></span><br><span class="line">			<span class="comment">// the amount of potentially wasted memory is bounded.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// Size of the memory block used for combining (maxTinySize) is tunable.</span></span><br><span class="line">			<span class="comment">// Current setting is 16 bytes, which relates to 2x worst case memory</span></span><br><span class="line">			<span class="comment">// wastage (when all but one subobjects are unreachable).</span></span><br><span class="line">			<span class="comment">// 8 bytes would result in no wastage at all, but provides less</span></span><br><span class="line">			<span class="comment">// opportunities for combining.</span></span><br><span class="line">			<span class="comment">// 32 bytes provides more opportunities for combining,</span></span><br><span class="line">			<span class="comment">// but can lead to 4x worst case wastage.</span></span><br><span class="line">			<span class="comment">// The best case winning is 8x regardless of block size.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// Objects obtained from tiny allocator must not be freed explicitly.</span></span><br><span class="line">			<span class="comment">// So when an object will be freed explicitly, we ensure that</span></span><br><span class="line">			<span class="comment">// its size &gt;= maxTinySize.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// SetFinalizer has a special case for objects potentially coming</span></span><br><span class="line">			<span class="comment">// from tiny allocator, it such case it allows to set finalizers</span></span><br><span class="line">			<span class="comment">// for an inner byte of a memory block.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// The main targets of tiny allocator are small strings and</span></span><br><span class="line">			<span class="comment">// standalone escaping variables. On a json benchmark</span></span><br><span class="line">			<span class="comment">// the allocator reduces number of allocations by ~12% and</span></span><br><span class="line">			<span class="comment">// reduces heap size by ~20%.</span></span><br><span class="line">      <span class="comment">//tiny allocator的主要目标是小字符串和独立的转义变量。在 json 基准测试中分配器将分配次数减少了约 12% 并且将堆大小减少约 20%</span></span><br><span class="line">			off := c.tinyoffset <span class="comment">//取出mcache中tiny区域上次用到的偏移量</span></span><br><span class="line">			<span class="comment">// Align tiny pointer for required (conservative) alignment.</span></span><br><span class="line">			<span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123; <span class="comment">//内存对齐</span></span><br><span class="line">				off = alignUp(off, <span class="number">8</span>) <span class="comment">//往上四舍五入到8的倍数，让每个变量从2的n次方处开始分配</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> sys.PtrSize == <span class="number">4</span> &amp;&amp; size == <span class="number">12</span> &#123;</span><br><span class="line">				<span class="comment">// Conservatively align 12-byte objects to 8 bytes on 32-bit</span></span><br><span class="line">				<span class="comment">// systems so that objects whose first field is a 64-bit</span></span><br><span class="line">				<span class="comment">// value is aligned to 8 bytes and does not cause a fault on</span></span><br><span class="line">				<span class="comment">// atomic access. See issue 37262.</span></span><br><span class="line">				<span class="comment">// TODO(mknyszek): Remove this workaround if/when issue 36606</span></span><br><span class="line">				<span class="comment">// is resolved.</span></span><br><span class="line">				off = alignUp(off, <span class="number">8</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = alignUp(off, <span class="number">4</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = alignUp(off, <span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123; <span class="comment">//如果此次分配后的偏移&lt;=16，同时tiny还有可用空间，则直接使用mcache的tiny内存块分配</span></span><br><span class="line">				<span class="comment">// The object fits into existing tiny block.</span></span><br><span class="line">				x = unsafe.Pointer(c.tiny + off) <span class="comment">//得到变量开始位置（区域应该是c.tiny + off ~ c.tiny + off + size）</span></span><br><span class="line">				c.tinyoffset = off + size <span class="comment">//更新偏移量</span></span><br><span class="line">				c.tinyAllocs++ <span class="comment">//记录分配的tiny对象的总个数</span></span><br><span class="line">				mp.mallocing = <span class="number">0</span> <span class="comment">//标记为分配结束</span></span><br><span class="line">				releasem(mp) <span class="comment">//放弃独占m</span></span><br><span class="line">				<span class="keyword">return</span> x <span class="comment">//返回变量的开始位置</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Allocate a new maxTinySize block.</span></span><br><span class="line">      <span class="comment">//没有可用的tiny对象给分配时：</span></span><br><span class="line">			span = c.alloc[tinySpanClass] <span class="comment">//向mcache申请</span></span><br><span class="line">			v := nextFreeFast(span) <span class="comment">// 得到一个tinySpanClass规格的span的可用区域的开始位置，先从allocCache中看是否有足够空闲的elem快速分配</span></span><br><span class="line">			<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">				v, span, shouldhelpgc = c.nextFree(tinySpanClass) <span class="comment">//没有足够的缓存空闲对象可用时，从中心缓存或者页堆中获取新的管理单元，在这时就可能触发垃圾收集；调用refill() （后文会展开详解），shouldhelpgc会等于true时会在下面判断是否要触发GC</span></span><br><span class="line">			&#125;</span><br><span class="line">			x = unsafe.Pointer(v) <span class="comment">//x是这个函数的返回值，v设置为返回值，也就是v就是变量开始位置</span></span><br><span class="line">			(*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">			(*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">			<span class="comment">// See if we need to replace the existing tiny block with the new one</span></span><br><span class="line">			<span class="comment">// based on amount of remaining free space.</span></span><br><span class="line">			<span class="keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="number">0</span> &#123;	<span class="comment">//看是否要用新的tiny小块替换原来的tiny块</span></span><br><span class="line">				c.tiny = <span class="type">uintptr</span>(x) <span class="comment">//设置新的tiny块</span></span><br><span class="line">				c.tinyoffset = size <span class="comment">//设置新的偏移量</span></span><br><span class="line">			&#125;</span><br><span class="line">			size = maxTinySize</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//分配的内存&gt;16byte且&lt;= 32k，或者是指针类型变量 : has pointer(scan) || (size &gt;= 16bytes &amp;&amp; size &lt;= 32KB)</span></span><br><span class="line">			<span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line">			<span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123; <span class="comment">//如果目标大小&lt;=1016b，就是下面的规格</span></span><br><span class="line">				sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]</span><br><span class="line">			&#125;</span><br><span class="line">			size = <span class="type">uintptr</span>(class_to_size[sizeclass]) <span class="comment">//得到规格的大小</span></span><br><span class="line">			spc := makeSpanClass(sizeclass, noscan) <span class="comment">//得到规格的大小</span></span><br><span class="line">			span = c.alloc[spc] <span class="comment">//取出这个规格的span</span></span><br><span class="line">			v := nextFreeFast(span)</span><br><span class="line">			<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">				v, span, shouldhelpgc = c.nextFree(spc) <span class="comment">//与tiny一样，mcache没有的话会向mcentral申请，mcentral没有会向mheap申请，具体详见refill方法</span></span><br><span class="line">			&#125;</span><br><span class="line">			x = unsafe.Pointer(v)</span><br><span class="line">			<span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">        memclrNoHeapPointers(unsafe.Pointer(v), size) <span class="comment">//个人理解是清理被分配的内存(清零)，保证是干净的</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//分配目标&gt;32KB</span></span><br><span class="line">		shouldhelpgc = <span class="literal">true</span></span><br><span class="line">		span = c.allocLarge(size, needzero, noscan) <span class="comment">//从mheap中分配内存</span></span><br><span class="line">		span.freeindex = <span class="number">1</span></span><br><span class="line">		span.allocCount = <span class="number">1</span></span><br><span class="line">		x = unsafe.Pointer(span.base())</span><br><span class="line">		size = span.elemsize</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> scanSize <span class="type">uintptr</span></span><br><span class="line">  <span class="comment">//设置arena对应的bitmap, 记录哪些位置包含了指针, GC会使用bitmap扫描所有可到达的对象</span></span><br><span class="line">	<span class="keyword">if</span> !noscan &#123; <span class="comment">//是指针</span></span><br><span class="line">		<span class="comment">// If allocating a defer+arg block, now that we&#x27;ve picked a malloc size</span></span><br><span class="line">		<span class="comment">// large enough to hold everything, cut the &quot;asked for&quot; size down to</span></span><br><span class="line">		<span class="comment">// just the defer header, so that the GC bitmap will record the arg block</span></span><br><span class="line">		<span class="comment">// as containing nothing at all (as if it were unused space at the end of</span></span><br><span class="line">		<span class="comment">// a malloc block caused by size rounding).</span></span><br><span class="line">		<span class="comment">// The defer arg areas are scanned as part of scanstack.</span></span><br><span class="line">		<span class="keyword">if</span> typ == deferType &#123;</span><br><span class="line">			dataSize = unsafe.Sizeof(_defer&#123;&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//根据编译期间对每个struct生成的type结构，用一个bitmap记录下来分配的内存块中哪些位置是指针。</span></span><br><span class="line">		heapBitsSetType(<span class="type">uintptr</span>(x), size, dataSize, typ)</span><br><span class="line">		<span class="keyword">if</span> dataSize &gt; typ.size &#123;</span><br><span class="line">			<span class="comment">// Array allocation. If there are any</span></span><br><span class="line">			<span class="comment">// pointers, GC has to scan to the last</span></span><br><span class="line">			<span class="comment">// element.</span></span><br><span class="line">			<span class="keyword">if</span> typ.ptrdata != <span class="number">0</span> &#123; <span class="comment">/// 数组分配。 如果有任何指针，GC 必须扫描到最后元素。</span></span><br><span class="line">				scanSize = dataSize - typ.size + typ.ptrdata</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			scanSize = typ.ptrdata</span><br><span class="line">		&#125;</span><br><span class="line">		c.scanAlloc += scanSize</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ensure that the stores above that initialize x to</span></span><br><span class="line">	<span class="comment">// type-safe memory and set the heap bits occur before</span></span><br><span class="line">	<span class="comment">// the caller can make x observable to the garbage</span></span><br><span class="line">	<span class="comment">// collector. Otherwise, on weakly ordered machines,</span></span><br><span class="line">	<span class="comment">// the garbage collector could follow a pointer to x,</span></span><br><span class="line">	<span class="comment">// but see uninitialized memory or stale heap bits.</span></span><br><span class="line">  <span class="comment">// 内存屏障, 因为x86和x64的store不会乱序所以这里只是个针对编译器的屏障, 汇编中是ret</span></span><br><span class="line">	publicationBarrier()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate black during GC.</span></span><br><span class="line">	<span class="comment">// All slots hold nil so no scanning is needed.</span></span><br><span class="line">	<span class="comment">// This may be racing with GC so do it atomically if there can be</span></span><br><span class="line">	<span class="comment">// a race marking the bit.</span></span><br><span class="line">	<span class="keyword">if</span> gcphase != _GCoff &#123; <span class="comment">// 如果当前在GC中, 需要立刻标记分配后的对象为&quot;黑色&quot;, 防止它被回收</span></span><br><span class="line">		gcmarknewobject(span, <span class="type">uintptr</span>(x), size, scanSize)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Race Detector的处理(用于检测线程冲突问题)</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racemalloc(x, size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Race Detector的处理(用于检测线程冲突问题)</span></span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanmalloc(x, size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mp.mallocing = <span class="number">0</span> <span class="comment">//标记结束</span></span><br><span class="line">	releasem(mp) <span class="comment">//放弃独占</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// trace记录</span></span><br><span class="line">	<span class="keyword">if</span> debug.malloc &#123;</span><br><span class="line">		<span class="keyword">if</span> debug.allocfreetrace != <span class="number">0</span> &#123;</span><br><span class="line">			tracealloc(x, size, typ)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> inittrace.active &amp;&amp; inittrace.id == getg().goid &#123;</span><br><span class="line">			<span class="comment">// Init functions are executed sequentially in a single Go routine.</span></span><br><span class="line">			inittrace.bytes += <span class="type">uint64</span>(size)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Profiler记录</span></span><br><span class="line">	<span class="keyword">if</span> rate := MemProfileRate; rate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> rate != <span class="number">1</span> &amp;&amp; size &lt; c.nextSample &#123;</span><br><span class="line">			c.nextSample -= size</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			mp := acquirem()</span><br><span class="line">			profilealloc(mp, x, size)</span><br><span class="line">			releasem(mp)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// gcAssistBytes减去&quot;实际分配大小 - 要求分配大小&quot;, 调整到准确值</span></span><br><span class="line">	<span class="keyword">if</span> assistG != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Account for internal fragmentation in the assist</span></span><br><span class="line">		<span class="comment">// debt now that we know it.</span></span><br><span class="line">		assistG.gcAssistBytes -= <span class="type">int64</span>(size - dataSize)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> shouldhelpgc &#123; <span class="comment">//如果之前获取了新的span, 则判断是否需要后台启动GC</span></span><br><span class="line">		<span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">			gcStart(t)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么是内存对齐？"><a href="#什么是内存对齐？" class="headerlink" title="什么是内存对齐？"></a>什么是内存对齐？</h4><p><img src="/images/golang-memory3.jpg" alt="image"></p>
<p>变量 a、b 各占据 3 字节的空间，内存对齐后，a、b 占据 4 字节空间，CPU 读取 b 变量的值只需要进行一次内存访问。如果不进行内存对齐，CPU 读取 b 变量的值需要进行 2 次内存访问。第一次访问得到 b 变量的第 1 个字节，第二次访问得到 b 变量的后两个字节。如果不进行内存对齐，很可能增加 CPU 访问内存的次数。</p>
<h4 id="runtime-nextFreeFast-尝试从缓存中快速分配"><a href="#runtime-nextFreeFast-尝试从缓存中快速分配" class="headerlink" title="runtime.nextFreeFast-尝试从缓存中快速分配"></a>runtime.nextFreeFast-尝试从缓存中快速分配</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextFreeFast returns the next free object if one is quickly available.</span></span><br><span class="line"><span class="comment">// Otherwise it returns 0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFreeFast</span><span class="params">(s *mspan)</span></span> gclinkptr &#123;</span><br><span class="line">  <span class="comment">// 获取第一个非0的bit是第几个, 查找哪个元素是未分配的</span></span><br><span class="line">	theBit := sys.Ctz64(s.allocCache) <span class="comment">// Is there a free object in the allocCache?</span></span><br><span class="line">	<span class="keyword">if</span> theBit &lt; <span class="number">64</span> &#123; <span class="comment">// 索引小于元素数量，证明找到了</span></span><br><span class="line">		result := s.freeindex + <span class="type">uintptr</span>(theBit)</span><br><span class="line">		<span class="keyword">if</span> result &lt; s.nelems &#123;</span><br><span class="line">			freeidx := result + <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> freeidx%<span class="number">64</span> == <span class="number">0</span> &amp;&amp; freeidx != s.nelems &#123; <span class="comment">// 可以被64整除时需要特殊处理</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			s.allocCache &gt;&gt;= <span class="type">uint</span>(theBit + <span class="number">1</span>) <span class="comment">// 更新freeindex和allocCache(高位都是0, 用尽以后会更新)</span></span><br><span class="line">			s.freeindex = freeidx </span><br><span class="line">      </span><br><span class="line">			s.allocCount++ <span class="comment">// 添加已分配的elem计数</span></span><br><span class="line">			<span class="keyword">return</span> gclinkptr(result*s.elemsize + s.base()) <span class="comment">// 返会分配到的元素地址</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="mcache-nextFree-申请新的span"><a href="#mcache-nextFree-申请新的span" class="headerlink" title="mcache.nextFree-申请新的span"></a>mcache.nextFree-申请新的span</h4><p>如果在freeindex后无法快速找到未分配的元素, 就需要调用<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L546">nextFree</a> :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextFree returns the next free object from the cached span if one is available.</span></span><br><span class="line"><span class="comment">// Otherwise it refills the cache with a span with an available object and</span></span><br><span class="line"><span class="comment">// returns that object along with a flag indicating that this was a heavy</span></span><br><span class="line"><span class="comment">// weight allocation. If it is a heavy weight allocation the caller must</span></span><br><span class="line"><span class="comment">// determine whether a new GC cycle needs to be started or if the GC is active</span></span><br><span class="line"><span class="comment">// whether this goroutine needs to assist the GC.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Must run in a non-preemptible context since otherwise the owner of</span></span><br><span class="line"><span class="comment">// c could change.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> nextFree(spc spanClass) (v gclinkptr, s *mspan, shouldhelpgc <span class="type">bool</span>) &#123;</span><br><span class="line">	s = c.alloc[spc]</span><br><span class="line">	shouldhelpgc = <span class="literal">false</span></span><br><span class="line">	freeIndex := s.nextFreeIndex()</span><br><span class="line">	<span class="keyword">if</span> freeIndex == s.nelems &#123; <span class="comment">// 如果span里面所有元素都已分配, 则需要获取新的span</span></span><br><span class="line">		<span class="comment">// The span is full.</span></span><br><span class="line">		<span class="keyword">if</span> <span class="type">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;runtime: s.allocCount=&quot;</span>, s.allocCount, <span class="string">&quot;s.nelems=&quot;</span>, s.nelems)</span><br><span class="line">			throw(<span class="string">&quot;s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		c.refill(spc) <span class="comment">//申请新的span</span></span><br><span class="line">		shouldhelpgc = <span class="literal">true</span></span><br><span class="line">		s = c.alloc[spc]</span><br><span class="line"></span><br><span class="line">		freeIndex = s.nextFreeIndex()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> freeIndex &gt;= s.nelems &#123;</span><br><span class="line">		throw(<span class="string">&quot;freeIndex is not valid&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返会分配到的元素地址</span></span><br><span class="line">	v = gclinkptr(freeIndex*s.elemsize + s.base())</span><br><span class="line">	s.allocCount++ <span class="comment">//更新分配计数</span></span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(s.allocCount) &gt; s.nelems &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;s.allocCount=&quot;</span>, s.allocCount, <span class="string">&quot;s.nelems=&quot;</span>, s.nelems)</span><br><span class="line">		throw(<span class="string">&quot;s.allocCount &gt; s.nelems&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="mcache-refill-向mcentral申请内存"><a href="#mcache-refill-向mcentral申请内存" class="headerlink" title="mcache.refill-向mcentral申请内存"></a>mcache.refill-向mcentral申请内存</h4><p>如果mcache中指定类型的span已满, 就需要调用<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mcache.go#L107">refill</a>函数申请新的span:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// refill acquires a new span of span class spc for c. This span will</span></span><br><span class="line"><span class="comment">// have at least one free object. The current span in c must be full.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Must run in a non-preemptible context since otherwise the owner of</span></span><br><span class="line"><span class="comment">// c could change.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> refill(spc spanClass) &#123;</span><br><span class="line">	<span class="comment">// Return the current cached span to the central lists.</span></span><br><span class="line">	s := c.alloc[spc]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(s.allocCount) != s.nelems &#123; <span class="comment">// 确保所有的span都已经被分配</span></span><br><span class="line">		throw(<span class="string">&quot;refill of span with free space remaining&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">		<span class="comment">// Mark this span as no longer cached.</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen != mheap_.sweepgen+<span class="number">3</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;bad sweepgen in refill&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		mheap_.central[spc].mcentral.uncacheSpan(s) <span class="comment">// 将span归还</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get a new cached span from the central lists.</span></span><br><span class="line">	s = mheap_.central[spc].mcentral.cacheSpan() <span class="comment">// 从mcentral中申请新的span</span></span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(s.allocCount) == s.nelems &#123;</span><br><span class="line">		throw(<span class="string">&quot;span has no free space&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Indicate that this span is cached and prevent asynchronous</span></span><br><span class="line">	<span class="comment">// sweeping in the next sweep phase.</span></span><br><span class="line">	s.sweepgen = mheap_.sweepgen + <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Assume all objects from this span will be allocated in the</span></span><br><span class="line">	<span class="comment">// mcache. If it gets uncached, we&#x27;ll adjust this.</span></span><br><span class="line">	stats := memstats.heapStats.acquire()</span><br><span class="line">	atomic.Xadduintptr(&amp;stats.smallAllocCount[spc.sizeclass()], <span class="type">uintptr</span>(s.nelems)-<span class="type">uintptr</span>(s.allocCount))</span><br><span class="line">	memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update heap_live with the same assumption.</span></span><br><span class="line">	usedBytes := <span class="type">uintptr</span>(s.allocCount) * s.elemsize</span><br><span class="line">	atomic.Xadd64(&amp;memstats.heap_live, <span class="type">int64</span>(s.npages*pageSize)-<span class="type">int64</span>(usedBytes))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Flush tinyAllocs.</span></span><br><span class="line">	<span class="keyword">if</span> spc == tinySpanClass &#123;</span><br><span class="line">		atomic.Xadd64(&amp;memstats.tinyallocs, <span class="type">int64</span>(c.tinyAllocs))</span><br><span class="line">		c.tinyAllocs = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// While we&#x27;re here, flush scanAlloc, since we have to call</span></span><br><span class="line">	<span class="comment">// revise anyway.</span></span><br><span class="line">	atomic.Xadd64(&amp;memstats.heap_scan, <span class="type">int64</span>(c.scanAlloc))</span><br><span class="line">	c.scanAlloc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		<span class="comment">// heap_live changed.</span></span><br><span class="line">		traceHeapAlloc()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// heap_live and heap_scan changed.</span></span><br><span class="line">		gcController.revise()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.alloc[spc] = s <span class="comment">// 设置新的span到mcache中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="mcentral-cacheSpan-向mcentral申请span"><a href="#mcentral-cacheSpan-向mcentral申请span" class="headerlink" title="mcentral.cacheSpan-向mcentral申请span"></a>mcentral.cacheSpan-向mcentral申请span</h4><p>向mcentral申请一个新的span会通过<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mcentral.go#L40">cacheSpan</a>函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a span to use in an mcache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> cacheSpan() *mspan &#123;</span><br><span class="line">	<span class="comment">// Deduct credit for this span allocation and sweep if necessary.</span></span><br><span class="line">  <span class="comment">// 让当前G协助一部分的sweep工作</span></span><br><span class="line">	spanBytes := <span class="type">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize</span><br><span class="line">	deductSweepCredit(spanBytes, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	sg := mheap_.sweepgen</span><br><span class="line"></span><br><span class="line">	traceDone := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCSweepStart()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we sweep spanBudget spans without finding any free</span></span><br><span class="line">	<span class="comment">// space, just allocate a fresh span. This limits the amount</span></span><br><span class="line">	<span class="comment">// of time we can spend trying to find free space and</span></span><br><span class="line">	<span class="comment">// amortizes the cost of small object sweeping over the</span></span><br><span class="line">	<span class="comment">// benefit of having a full free span to allocate from. By</span></span><br><span class="line">	<span class="comment">// setting this to 100, we limit the space overhead to 1%.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// TODO(austin,mknyszek): This still has bad worst-case</span></span><br><span class="line">	<span class="comment">// throughput. For example, this could find just one free slot</span></span><br><span class="line">	<span class="comment">// on the 100th swept span. That limits allocation latency, but</span></span><br><span class="line">	<span class="comment">// still has very poor throughput. We could instead keep a</span></span><br><span class="line">	<span class="comment">// running free-to-used budget and switch to fresh span</span></span><br><span class="line">	<span class="comment">// allocation if the budget runs low.</span></span><br><span class="line">	spanBudget := <span class="number">100</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> s *mspan</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// **新版中的 partial，full对应老版本的nonemptyh和enpty两个链表，partial维护该span最少有一个未分配的元素，full表示不确定该span最少有一个未分配的元素,优先从 partial 中查找</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Try partial swept spans first.</span></span><br><span class="line">  <span class="comment">// 从清理过的、包含空闲空间的spanSet结构中查找可以使用的内存管理单元</span></span><br><span class="line">	<span class="keyword">if</span> s = c.partialSwept(sg).pop(); s != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> havespan</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now try partial unswept spans.</span></span><br><span class="line">	<span class="keyword">for</span> ; spanBudget &gt;= <span class="number">0</span>; spanBudget-- &#123;</span><br><span class="line">		s = c.partialUnswept(sg).pop() <span class="comment">// 从未被清理过的、有空闲对象的spanSet查找可用的span</span></span><br><span class="line">		<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.Load(&amp;s.sweepgen) == sg<span class="number">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">// We got ownership of the span, so let&#x27;s sweep it and use it.</span></span><br><span class="line">      <span class="comment">// 找到要回收的span，触发sweep进行清理</span></span><br><span class="line">			s.sweep(<span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">goto</span> havespan</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// We failed to get ownership of the span, which means it&#x27;s being or</span></span><br><span class="line">		<span class="comment">// has been swept by an asynchronous sweeper that just couldn&#x27;t remove it</span></span><br><span class="line">		<span class="comment">// from the unswept list. That sweeper took ownership of the span and</span></span><br><span class="line">		<span class="comment">// responsibility for either freeing it to the heap or putting it on the</span></span><br><span class="line">		<span class="comment">// right swept list. Either way, we should just ignore it (and it&#x27;s unsafe</span></span><br><span class="line">		<span class="comment">// for us to do anything else).</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Now try full unswept spans, sweeping them and putting them into the</span></span><br><span class="line">	<span class="comment">// right list if we fail to get a span.</span></span><br><span class="line">	<span class="keyword">for</span> ; spanBudget &gt;= <span class="number">0</span>; spanBudget-- &#123;</span><br><span class="line">		s = c.fullUnswept(sg).pop() <span class="comment">// 获取未被清理的、不包含空闲空间的spanSet查找可用的span</span></span><br><span class="line">		<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.Load(&amp;s.sweepgen) == sg<span class="number">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">// We got ownership of the span, so let&#x27;s sweep it.</span></span><br><span class="line">			s.sweep(<span class="literal">true</span>)</span><br><span class="line">			<span class="comment">// Check if there&#x27;s any free space.</span></span><br><span class="line">			freeIndex := s.nextFreeIndex()</span><br><span class="line">			<span class="keyword">if</span> freeIndex != s.nelems &#123;</span><br><span class="line">				s.freeindex = freeIndex</span><br><span class="line">				<span class="keyword">goto</span> havespan</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Add it to the swept list, because sweeping didn&#x27;t give us any free space.</span></span><br><span class="line">			c.fullSwept(sg).push(s)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// See comment for partial unswept spans.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCSweepDone()</span><br><span class="line">		traceDone = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We failed to get a span from the mcentral so get one from mheap.</span></span><br><span class="line">  <span class="comment">// 从堆中申请新的内存管理单元</span></span><br><span class="line">	s = c.grow()</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// At this point s is a span that should have free slots.</span></span><br><span class="line">havespan:</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &amp;&amp; !traceDone &#123;</span><br><span class="line">		traceGCSweepDone()</span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="type">int</span>(s.nelems) - <span class="type">int</span>(s.allocCount)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> || s.freeindex == s.nelems || <span class="type">uintptr</span>(s.allocCount) == s.nelems &#123;</span><br><span class="line">		throw(<span class="string">&quot;span has no free objects&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	freeByteBase := s.freeindex &amp;^ (<span class="number">64</span> - <span class="number">1</span>)</span><br><span class="line">	whichByte := freeByteBase / <span class="number">8</span></span><br><span class="line">	<span class="comment">// Init alloc bits cache.</span></span><br><span class="line">	s.refillAllocCache(whichByte)  <span class="comment">// 更新AllocCache</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adjust the allocCache so that s.freeindex corresponds to the low bit in</span></span><br><span class="line">	<span class="comment">// s.allocCache.</span></span><br><span class="line">	s.allocCache &gt;&gt;= s.freeindex % <span class="number">64</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="mcentral-grow-向heap申请内存"><a href="#mcentral-grow-向heap申请内存" class="headerlink" title="mcentral.grow-向heap申请内存"></a>mcentral.grow-向heap申请内存</h4><p>mcentral向mheap申请一个新的span会使用<a href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mcentral.go#L227">grow</a>函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// grow allocates a new empty span from the heap and initializes it for c&#x27;s size class.func (c *mcentral) grow() *mspan &#123;  // 根据mcentral的类型计算需要申请的span的大小(除以8K = 有多少页)和可以保存多少个元素	npages := uintptr(class_to_allocnpages[c.spanclass.sizeclass()])	size := uintptr(class_to_size[c.spanclass.sizeclass()])  // 向mheap申请一个新的span, 以页(8K)为单位	s := mheap_.alloc(npages, c.spanclass, true)	if s == nil &#123;		return nil	&#125;	// Use division by multiplication and shifts to quickly compute:	// n := (npages &lt;&lt; _PageShift) / size	n := (npages &lt;&lt; _PageShift) &gt;&gt; s.divShift * uintptr(s.divMul) &gt;&gt; s.divShift2	s.limit = s.base() + size*n // 更新limit	heapBitsForAddr(s.base()).initSpan(s) // 分配并初始化span的allocBits和gcmarkBits	return s&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="mcache-allocLarge-大对象分配"><a href="#mcache-allocLarge-大对象分配" class="headerlink" title="mcache.allocLarge-大对象分配"></a>mcache.allocLarge-大对象分配</h4><p>对于大对象的分配allocLarge，直接回向mheap申请，同mheap_.alloc</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocLarge allocates a span for a large object.func (c *mcache) allocLarge(size uintptr, needzero bool, noscan bool) *mspan &#123;	if size+_PageSize &lt; size &#123;		throw(&quot;out of memory&quot;)	&#125;	npages := size &gt;&gt; _PageShift	if size&amp;_PageMask != 0 &#123;		npages++	&#125;	// Deduct credit for this span allocation and sweep if	// necessary. mHeap_Alloc will also sweep npages, so this only	// pays the debt down to npage pages.	deductSweepCredit(npages*_PageSize, npages)	spc := makeSpanClass(0, noscan)	s := mheap_.alloc(npages, spc, needzero)	if s == nil &#123;		throw(&quot;out of memory&quot;)	&#125;	stats := memstats.heapStats.acquire()	atomic.Xadduintptr(&amp;stats.largeAlloc, npages*pageSize)	atomic.Xadduintptr(&amp;stats.largeAllocCount, 1)	memstats.heapStats.release()	// Update heap_live and revise pacing if needed.	atomic.Xadd64(&amp;memstats.heap_live, int64(npages*pageSize))	if trace.enabled &#123;		// Trace that a heap alloc occurred because heap_live changed.		traceHeapAlloc()	&#125;	if gcBlackenEnabled != 0 &#123;		gcController.revise()	&#125;	// Put the large span in the mcentral swept list so that it&#x27;s	// visible to the background sweeper.	mheap_.central[spc].mcentral.fullSwept(mheap_.sweepgen).push(s)	s.limit = s.base() + size	heapBitsForAddr(s.base()).initSpan(s)	return s&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="mheap分配流程"><a href="#mheap分配流程" class="headerlink" title="mheap分配流程"></a>mheap分配流程</h4><h5 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alloc allocates a new span of npage pages from the GC&#x27;d heap.//// spanclass indicates the span&#x27;s size class and scannability.//// If needzero is true, the memory for the returned span will be zeroed.func (h *mheap) alloc(npages uintptr, spanclass spanClass, needzero bool) *mspan &#123;	// Don&#x27;t do any operations that lock the heap on the G stack.	// It might trigger stack growth, and the stack growth code needs	// to be able to allocate heap.	var s *mspan	systemstack(func() &#123;		// To prevent excessive heap growth, before allocating n pages		// we need to sweep and reclaim at least n pages.		if h.sweepdone == 0 &#123;			h.reclaim(npages) // 回收一部分内存		&#125;		s = h.allocSpan(npages, spanAllocHeap, spanclass) // 申请内存	&#125;)	if s != nil &#123;		if needzero &amp;&amp; s.needzero != 0 &#123;			memclrNoHeapPointers(unsafe.Pointer(s.base()), s.npages&lt;&lt;_PageShift)		&#125;		s.needzero = 0	&#125;	return s&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="allocSpan"><a href="#allocSpan" class="headerlink" title="allocSpan"></a>allocSpan</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocSpan(npages <span class="type">uintptr</span>, typ spanAllocType, spanclass spanClass) (s *mspan) &#123;</span><br><span class="line">	<span class="comment">// Function-global state.</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	base, scav := <span class="type">uintptr</span>(<span class="number">0</span>), <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// On some platforms we need to provide physical page aligned stack</span></span><br><span class="line">	<span class="comment">// allocations. Where the page size is less than the physical page</span></span><br><span class="line">	<span class="comment">// size, we already manage to do this by default.</span></span><br><span class="line">	needPhysPageAlign := physPageAlignedStacks &amp;&amp; typ == spanAllocStack &amp;&amp; pageSize &lt; physPageSize</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the allocation is small enough, try the page cache!</span></span><br><span class="line">	<span class="comment">// The page cache does not support aligned allocations, so we cannot use</span></span><br><span class="line">	<span class="comment">// it if we need to provide a physical page aligned stack allocation.</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">//这里会根据需要分配的内存大小再判断一次：</span></span><br><span class="line"><span class="comment">//如果要分配的页数小于pageCachePages/4=64/4=16页，那么就尝试从pcache申请内存；</span></span><br><span class="line"><span class="comment">//如果申请的内存比较大或者线程的页缓存中内存不足，会通过runtime.pageAlloc.alloc从页堆分配内存；</span></span><br><span class="line"><span class="comment">//如果页堆上内存不足，那么就mheap的grow方法从系统上申请内存，然后再调用pageAlloc的alloc分配内存；</span></span><br><span class="line">  </span><br><span class="line">	pp := gp.m.p.ptr()</span><br><span class="line">	<span class="keyword">if</span> !needPhysPageAlign &amp;&amp; pp != <span class="literal">nil</span> &amp;&amp; npages &lt; pageCachePages/<span class="number">4</span> &#123; <span class="comment">//申请的内存比较小,尝试从pcache申请内存</span></span><br><span class="line">		c := &amp;pp.pcache</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If the cache is empty, refill it.</span></span><br><span class="line">		<span class="keyword">if</span> c.empty() &#123;</span><br><span class="line">			lock(&amp;h.lock)</span><br><span class="line">			*c = h.pages.allocToCache()</span><br><span class="line">			unlock(&amp;h.lock)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Try to allocate from the cache.</span></span><br><span class="line">		base, scav = c.alloc(npages)</span><br><span class="line">		<span class="keyword">if</span> base != <span class="number">0</span> &#123;</span><br><span class="line">			s = h.tryAllocMSpan()</span><br><span class="line">			<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> HaveSpan</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// We have a base but no mspan, so we need</span></span><br><span class="line">			<span class="comment">// to lock the heap.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// For one reason or another, we couldn&#x27;t get the</span></span><br><span class="line">	<span class="comment">// whole job done without the heap lock.</span></span><br><span class="line">	lock(&amp;h.lock) <span class="comment">// 对mheap上锁, 这里的锁是全局锁</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> needPhysPageAlign &#123;</span><br><span class="line">		<span class="comment">// Overallocate by a physical page to allow for later alignment.</span></span><br><span class="line">		npages += physPageSize / pageSize</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Try to acquire a base address.</span></span><br><span class="line">		base, scav = h.pages.alloc(npages) <span class="comment">// 内存比较大或者线程的页缓存中内存不足，从mheap的pages上获取内存</span></span><br><span class="line">		<span class="keyword">if</span> base == <span class="number">0</span> &#123; <span class="comment">// 内存也不够，那么进行扩容</span></span><br><span class="line">			<span class="keyword">if</span> !h.grow(npages) &#123;  <span class="comment">// 从操作系统申请</span></span><br><span class="line">				unlock(&amp;h.lock)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			base, scav = h.pages.alloc(npages) <span class="comment">// 重新申请内存</span></span><br><span class="line">			<span class="keyword">if</span> base == <span class="number">0</span> &#123; <span class="comment">// 内存不足时抛出异常</span></span><br><span class="line">				throw(<span class="string">&quot;grew heap, but no adequate free space found&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// We failed to get an mspan earlier, so grab</span></span><br><span class="line">		<span class="comment">// one now that we have the heap lock.</span></span><br><span class="line">		s = h.allocMSpanLocked() <span class="comment">// 分配一个mspan对象</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> needPhysPageAlign &#123; <span class="comment">// 需要对齐</span></span><br><span class="line">		allocBase, allocPages := base, npages</span><br><span class="line">		base = alignUp(allocBase, physPageSize)</span><br><span class="line">		npages -= physPageSize / pageSize</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Return memory around the aligned allocation.</span></span><br><span class="line">		spaceBefore := base - allocBase</span><br><span class="line">		<span class="keyword">if</span> spaceBefore &gt; <span class="number">0</span> &#123;</span><br><span class="line">			h.pages.free(allocBase, spaceBefore/pageSize)</span><br><span class="line">		&#125;</span><br><span class="line">		spaceAfter := (allocPages-npages)*pageSize - spaceBefore</span><br><span class="line">		<span class="keyword">if</span> spaceAfter &gt; <span class="number">0</span> &#123;</span><br><span class="line">			h.pages.free(base+npages*pageSize, spaceAfter/pageSize)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	unlock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">HaveSpan:</span><br><span class="line">	<span class="comment">// At this point, both s != nil and base != 0, and the heap</span></span><br><span class="line">	<span class="comment">// lock is no longer held. Initialize the span.</span></span><br><span class="line">	s.init(base, npages) <span class="comment">// 初始化新的page</span></span><br><span class="line">	<span class="keyword">if</span> h.allocNeedsZero(base, npages) &#123;</span><br><span class="line">		s.needzero = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	nbytes := npages * pageSize</span><br><span class="line">	<span class="keyword">if</span> typ.manual() &#123;</span><br><span class="line">		s.manualFreeList = <span class="number">0</span></span><br><span class="line">		s.nelems = <span class="number">0</span></span><br><span class="line">		s.limit = s.base() + s.npages*pageSize</span><br><span class="line">		s.state.set(mSpanManual)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// We must set span properties before the span is published anywhere</span></span><br><span class="line">		<span class="comment">// since we&#x27;re not holding the heap lock.</span></span><br><span class="line">		s.spanclass = spanclass</span><br><span class="line">		<span class="keyword">if</span> sizeclass := spanclass.sizeclass(); sizeclass == <span class="number">0</span> &#123;</span><br><span class="line">			s.elemsize = nbytes</span><br><span class="line">			s.nelems = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">			s.divShift = <span class="number">0</span></span><br><span class="line">			s.divMul = <span class="number">0</span></span><br><span class="line">			s.divShift2 = <span class="number">0</span></span><br><span class="line">			s.baseMask = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			s.elemsize = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">			s.nelems = nbytes / s.elemsize</span><br><span class="line"></span><br><span class="line">			m := &amp;class_to_divmagic[sizeclass]</span><br><span class="line">			s.divShift = m.shift</span><br><span class="line">			s.divMul = m.mul</span><br><span class="line">			s.divShift2 = m.shift2</span><br><span class="line">			s.baseMask = m.baseMask</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize mark and allocation structures.</span></span><br><span class="line">		s.freeindex = <span class="number">0</span></span><br><span class="line">		s.allocCache = ^<span class="type">uint64</span>(<span class="number">0</span>) <span class="comment">// all 1s indicating all free.</span></span><br><span class="line">		s.gcmarkBits = newMarkBits(s.nelems)</span><br><span class="line">		s.allocBits = newAllocBits(s.nelems)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// It&#x27;s safe to access h.sweepgen without the heap lock because it&#x27;s</span></span><br><span class="line">		<span class="comment">// only ever updated with the world stopped and we run on the</span></span><br><span class="line">		<span class="comment">// systemstack which blocks a STW transition.</span></span><br><span class="line">		atomic.Store(&amp;s.sweepgen, h.sweepgen)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Now that the span is filled in, set its state. This</span></span><br><span class="line">		<span class="comment">// is a publication barrier for the other fields in</span></span><br><span class="line">		<span class="comment">// the span. While valid pointers into this span</span></span><br><span class="line">		<span class="comment">// should never be visible until the span is returned,</span></span><br><span class="line">		<span class="comment">// if the garbage collector finds an invalid pointer,</span></span><br><span class="line">		<span class="comment">// access to the span may race with initialization of</span></span><br><span class="line">		<span class="comment">// the span. We resolve this race by atomically</span></span><br><span class="line">		<span class="comment">// setting the state after the span is fully</span></span><br><span class="line">		<span class="comment">// initialized, and atomically checking the state in</span></span><br><span class="line">		<span class="comment">// any situation where a pointer is suspect.</span></span><br><span class="line">		s.state.set(mSpanInUse)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Commit and account for any scavenged memory that the span now owns.</span></span><br><span class="line">	<span class="keyword">if</span> scav != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// sysUsed all the pages that are actually available</span></span><br><span class="line">		<span class="comment">// in the span since some of them might be scavenged.</span></span><br><span class="line">		sysUsed(unsafe.Pointer(base), nbytes)</span><br><span class="line">		atomic.Xadd64(&amp;memstats.heap_released, -<span class="type">int64</span>(scav))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Update stats.</span></span><br><span class="line">	<span class="keyword">if</span> typ == spanAllocHeap &#123;</span><br><span class="line">		atomic.Xadd64(&amp;memstats.heap_inuse, <span class="type">int64</span>(nbytes))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> typ.manual() &#123;</span><br><span class="line">		<span class="comment">// Manually managed memory doesn&#x27;t count toward heap_sys.</span></span><br><span class="line">		memstats.heap_sys.add(-<span class="type">int64</span>(nbytes))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Update consistent stats.</span></span><br><span class="line">	stats := memstats.heapStats.acquire()</span><br><span class="line">	atomic.Xaddint64(&amp;stats.committed, <span class="type">int64</span>(scav))</span><br><span class="line">	atomic.Xaddint64(&amp;stats.released, -<span class="type">int64</span>(scav))</span><br><span class="line">	<span class="keyword">switch</span> typ &#123;</span><br><span class="line">	<span class="keyword">case</span> spanAllocHeap:</span><br><span class="line">		atomic.Xaddint64(&amp;stats.inHeap, <span class="type">int64</span>(nbytes))</span><br><span class="line">	<span class="keyword">case</span> spanAllocStack:</span><br><span class="line">		atomic.Xaddint64(&amp;stats.inStacks, <span class="type">int64</span>(nbytes))</span><br><span class="line">	<span class="keyword">case</span> spanAllocPtrScalarBits:</span><br><span class="line">		atomic.Xaddint64(&amp;stats.inPtrScalarBits, <span class="type">int64</span>(nbytes))</span><br><span class="line">	<span class="keyword">case</span> spanAllocWorkBuf:</span><br><span class="line">		atomic.Xaddint64(&amp;stats.inWorkBufs, <span class="type">int64</span>(nbytes))</span><br><span class="line">	&#125;</span><br><span class="line">	memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Publish the span in various locations.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// This is safe to call without the lock held because the slots</span></span><br><span class="line">	<span class="comment">// related to this span will only ever be read or modified by</span></span><br><span class="line">	<span class="comment">// this thread until pointers into the span are published (and</span></span><br><span class="line">	<span class="comment">// we execute a publication barrier at the end of this function</span></span><br><span class="line">	<span class="comment">// before that happens) or pageInUse is updated.</span></span><br><span class="line">	h.setSpans(s.base(), npages, s)  <span class="comment">// // 建立mheap与mspan之间的联系</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !typ.manual() &#123;</span><br><span class="line">		<span class="comment">// Mark in-use span in arena page bitmap.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// This publishes the span to the page sweeper, so</span></span><br><span class="line">		<span class="comment">// it&#x27;s imperative that the span be completely initialized</span></span><br><span class="line">		<span class="comment">// prior to this line.</span></span><br><span class="line">		arena, pageIdx, pageMask := pageIndexOf(s.base())</span><br><span class="line">		atomic.Or8(&amp;arena.pageInUse[pageIdx], pageMask)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update related page sweeper stats.</span></span><br><span class="line">		atomic.Xadd64(&amp;h.pagesInUse, <span class="type">int64</span>(npages))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure the newly allocated span will be observed</span></span><br><span class="line">	<span class="comment">// by the GC before pointers into the span are published.</span></span><br><span class="line">	publicationBarrier()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grow-向操作系统申请内存"><a href="#grow-向操作系统申请内存" class="headerlink" title="grow-向操作系统申请内存"></a>grow-向操作系统申请内存</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try to add at least npage pages of memory to the heap,</span></span><br><span class="line"><span class="comment">// returning whether it worked.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// h.lock must be held.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> grow(npage <span class="type">uintptr</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We must grow the heap in whole palloc chunks.</span></span><br><span class="line">	ask := alignUp(npage, pallocChunkPages) * pageSize</span><br><span class="line"></span><br><span class="line">	totalGrowth := <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="comment">// This may overflow because ask could be very large</span></span><br><span class="line">	<span class="comment">// and is otherwise unrelated to h.curArena.base.</span></span><br><span class="line">	end := h.curArena.base + ask</span><br><span class="line">	nBase := alignUp(end, physPageSize)</span><br><span class="line">  <span class="comment">// 内存不够则或溢出调用sysAlloc申请内存</span></span><br><span class="line">	<span class="keyword">if</span> nBase &gt; h.curArena.end || <span class="comment">/* overflow */</span> end &lt; h.curArena.base &#123;</span><br><span class="line">		<span class="comment">// Not enough room in the current arena. Allocate more</span></span><br><span class="line">		<span class="comment">// arena space. This may not be contiguous with the</span></span><br><span class="line">		<span class="comment">// current arena, so we have to request the full ask.</span></span><br><span class="line">		av, asize := h.sysAlloc(ask)</span><br><span class="line">		<span class="keyword">if</span> av == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime: out of memory: cannot allocate &quot;</span>, ask, <span class="string">&quot;-byte block (&quot;</span>, memstats.heap_sys, <span class="string">&quot; in use)\n&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新设置curArena的值</span></span><br><span class="line">		<span class="keyword">if</span> <span class="type">uintptr</span>(av) == h.curArena.end &#123;</span><br><span class="line">			<span class="comment">// The new space is contiguous with the old</span></span><br><span class="line">			<span class="comment">// space, so just extend the current space.</span></span><br><span class="line">			h.curArena.end = <span class="type">uintptr</span>(av) + asize</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// The new space is discontiguous. Track what</span></span><br><span class="line">			<span class="comment">// remains of the current space and switch to</span></span><br><span class="line">			<span class="comment">// the new space. This should be rare.</span></span><br><span class="line">			<span class="keyword">if</span> size := h.curArena.end - h.curArena.base; size != <span class="number">0</span> &#123;</span><br><span class="line">				h.pages.grow(h.curArena.base, size)</span><br><span class="line">				totalGrowth += size</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Switch to the new space.</span></span><br><span class="line">			h.curArena.base = <span class="type">uintptr</span>(av)</span><br><span class="line">			h.curArena.end = <span class="type">uintptr</span>(av) + asize</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// The memory just allocated counts as both released</span></span><br><span class="line">		<span class="comment">// and idle, even though it&#x27;s not yet backed by spans.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// The allocation is always aligned to the heap arena</span></span><br><span class="line">		<span class="comment">// size which is always &gt; physPageSize, so its safe to</span></span><br><span class="line">		<span class="comment">// just add directly to heap_released.</span></span><br><span class="line">		atomic.Xadd64(&amp;memstats.heap_released, <span class="type">int64</span>(asize))</span><br><span class="line">		stats := memstats.heapStats.acquire()</span><br><span class="line">		atomic.Xaddint64(&amp;stats.released, <span class="type">int64</span>(asize))</span><br><span class="line">		memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Recalculate nBase.</span></span><br><span class="line">		<span class="comment">// We know this won&#x27;t overflow, because sysAlloc returned</span></span><br><span class="line">		<span class="comment">// a valid region starting at h.curArena.base which is at</span></span><br><span class="line">		<span class="comment">// least ask bytes in size.</span></span><br><span class="line">		nBase = alignUp(h.curArena.base+ask, physPageSize)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Grow into the current arena.</span></span><br><span class="line">	v := h.curArena.base</span><br><span class="line">	h.curArena.base = nBase</span><br><span class="line">	h.pages.grow(v, nBase-v)</span><br><span class="line">	totalGrowth += nBase - v</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We just caused a heap growth, so scavenge down what will soon be used.</span></span><br><span class="line">	<span class="comment">// By scavenging inline we deal with the failure to allocate out of</span></span><br><span class="line">	<span class="comment">// memory fragments by scavenging the memory fragments that are least</span></span><br><span class="line">	<span class="comment">// likely to be re-used.</span></span><br><span class="line">	<span class="keyword">if</span> retained := heapRetained(); retained+<span class="type">uint64</span>(totalGrowth) &gt; h.scavengeGoal &#123;</span><br><span class="line">		todo := totalGrowth</span><br><span class="line">		<span class="keyword">if</span> overage := <span class="type">uintptr</span>(retained + <span class="type">uint64</span>(totalGrowth) - h.scavengeGoal); todo &gt; overage &#123;</span><br><span class="line">			todo = overage</span><br><span class="line">		&#125;</span><br><span class="line">		h.pages.scavenge(todo, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sysAlloc"><a href="#sysAlloc" class="headerlink" title="sysAlloc"></a>sysAlloc</h4><p>grow会通过curArena的end值来判断是不是需要从系统申请内存；如果end小于nBase那么会调用runtime.mheap.sysAlloc方法从操作系统中申请更多的内存 :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysAlloc allocates heap arena space for at least n bytes. The</span></span><br><span class="line"><span class="comment">// returned pointer is always heapArenaBytes-aligned and backed by</span></span><br><span class="line"><span class="comment">// h.arenas metadata. The returned size is always a multiple of</span></span><br><span class="line"><span class="comment">// heapArenaBytes. sysAlloc returns nil on failure.</span></span><br><span class="line"><span class="comment">// There is no corresponding free function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sysAlloc returns a memory region in the Prepared state. This region must</span></span><br><span class="line"><span class="comment">// be transitioned to Ready before use.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// h must be locked.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> sysAlloc(n <span class="type">uintptr</span>) (v unsafe.Pointer, size <span class="type">uintptr</span>) &#123;</span><br><span class="line">	assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">	n = alignUp(n, heapArenaBytes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First, try the arena pre-reservation.</span></span><br><span class="line">  <span class="comment">// 尝试先在预先保留的内存中申请一块可以使用的空间</span></span><br><span class="line">	v = h.arena.alloc(n, heapArenaBytes, &amp;memstats.heap_sys)</span><br><span class="line">	<span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">		size = n</span><br><span class="line">		<span class="keyword">goto</span> mapped</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Try to grow the heap at a hint address.</span></span><br><span class="line">	<span class="keyword">for</span> h.arenaHints != <span class="literal">nil</span> &#123; <span class="comment">// 根据页堆的arenaHints在目标地址上尝试扩容</span></span><br><span class="line">		hint := h.arenaHints</span><br><span class="line">		p := hint.addr</span><br><span class="line">		<span class="keyword">if</span> hint.down &#123;</span><br><span class="line">			p -= n</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p+n &lt; p &#123;</span><br><span class="line">			<span class="comment">// We can&#x27;t use this, so don&#x27;t ask.</span></span><br><span class="line">			v = <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> arenaIndex(p+n<span class="number">-1</span>) &gt;= <span class="number">1</span>&lt;&lt;arenaBits &#123;</span><br><span class="line">			<span class="comment">// Outside addressable heap. Can&#x27;t use.</span></span><br><span class="line">			v = <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			v = sysReserve(unsafe.Pointer(p), n) <span class="comment">// 从操作系统中申请内存</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p == <span class="type">uintptr</span>(v) &#123;</span><br><span class="line">			<span class="comment">// Success. Update the hint.</span></span><br><span class="line">			<span class="keyword">if</span> !hint.down &#123;</span><br><span class="line">				p += n</span><br><span class="line">			&#125;</span><br><span class="line">			hint.addr = p</span><br><span class="line">			size = n</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Failed. Discard this hint and try the next.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> This would be cleaner if sysReserve could be</span></span><br><span class="line">		<span class="comment">// told to only return the requested address. In</span></span><br><span class="line">		<span class="comment">// particular, this is already how Windows behaves, so</span></span><br><span class="line">		<span class="comment">// it would simplify things there.</span></span><br><span class="line">		<span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">			sysFree(v, n, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		h.arenaHints = hint.next</span><br><span class="line">		h.arenaHintAlloc.free(unsafe.Pointer(hint))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			<span class="comment">// The race detector assumes the heap lives in</span></span><br><span class="line">			<span class="comment">// [0x00c000000000, 0x00e000000000), but we</span></span><br><span class="line">			<span class="comment">// just ran out of hints in this region. Give</span></span><br><span class="line">			<span class="comment">// a nice failure.</span></span><br><span class="line">			throw(<span class="string">&quot;too many address space collisions for -race mode&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// All of the hints failed, so we&#x27;ll take any</span></span><br><span class="line">		<span class="comment">// (sufficiently aligned) address the kernel will give</span></span><br><span class="line">		<span class="comment">// us.</span></span><br><span class="line">		v, size = sysReserveAligned(<span class="literal">nil</span>, n, heapArenaBytes)</span><br><span class="line">		<span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create new hints for extending this region.</span></span><br><span class="line">		hint := (*arenaHint)(h.arenaHintAlloc.alloc())</span><br><span class="line">		hint.addr, hint.down = <span class="type">uintptr</span>(v), <span class="literal">true</span></span><br><span class="line">		hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">		hint = (*arenaHint)(h.arenaHintAlloc.alloc())</span><br><span class="line">		hint.addr = <span class="type">uintptr</span>(v) + size</span><br><span class="line">		hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check for bad pointers or pointers we can&#x27;t use.</span></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Transition from Reserved to Prepared.</span></span><br><span class="line">	sysMap(v, size, &amp;memstats.heap_sys) <span class="comment">// 将内存由Reserved转为Prepared</span></span><br><span class="line"></span><br><span class="line">mapped:</span><br><span class="line">	<span class="comment">// Create arena metadata.</span></span><br><span class="line">	<span class="comment">// 初始化一个新的heapArena来管理刚刚申请的内存</span></span><br><span class="line">	<span class="keyword">for</span> ri := arenaIndex(<span class="type">uintptr</span>(v)); ri &lt;= arenaIndex(<span class="type">uintptr</span>(v)+size<span class="number">-1</span>); ri++ &#123;</span><br><span class="line">		l2 := h.arenas[ri.l1()]</span><br><span class="line">		<span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// Allocate an L2 arena map.</span></span><br><span class="line">			l2 = (*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena)(persistentalloc(unsafe.Sizeof(*l2), sys.PtrSize, <span class="literal">nil</span>))</span><br><span class="line">			<span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;out of memory allocating heap arena map&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			atomic.StorepNoWB(unsafe.Pointer(&amp;h.arenas[ri.l1()]), unsafe.Pointer(l2))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> l2[ri.l2()] != <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;arena already initialized&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> r *heapArena</span><br><span class="line">		r = (*heapArena)(h.heapArenaAlloc.alloc(unsafe.Sizeof(*r), sys.PtrSize, &amp;memstats.gcMiscSys))</span><br><span class="line">		<span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">			r = (*heapArena)(persistentalloc(unsafe.Sizeof(*r), sys.PtrSize, &amp;memstats.gcMiscSys))</span><br><span class="line">			<span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;out of memory allocating heap arena metadata&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Add the arena to the arenas list.</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(h.allArenas) == <span class="built_in">cap</span>(h.allArenas) &#123;</span><br><span class="line">			size := <span class="number">2</span> * <span class="type">uintptr</span>(<span class="built_in">cap</span>(h.allArenas)) * sys.PtrSize</span><br><span class="line">			<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">				size = physPageSize</span><br><span class="line">			&#125;</span><br><span class="line">			newArray := (*notInHeap)(persistentalloc(size, sys.PtrSize, &amp;memstats.gcMiscSys))</span><br><span class="line">			<span class="keyword">if</span> newArray == <span class="literal">nil</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;out of memory allocating allArenas&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			oldSlice := h.allArenas</span><br><span class="line">			*(*notInHeapSlice)(unsafe.Pointer(&amp;h.allArenas)) = notInHeapSlice&#123;newArray, <span class="built_in">len</span>(h.allArenas), <span class="type">int</span>(size / sys.PtrSize)&#125;</span><br><span class="line">			<span class="built_in">copy</span>(h.allArenas, oldSlice)</span><br><span class="line">			<span class="comment">// Do not free the old backing array because</span></span><br><span class="line">			<span class="comment">// there may be concurrent readers. Since we</span></span><br><span class="line">			<span class="comment">// double the array each time, this can lead</span></span><br><span class="line">			<span class="comment">// to at most 2x waste.</span></span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// // 将创建heapArena放入到arenas列表中</span></span><br><span class="line">		h.allArenas = h.allArenas[:<span class="built_in">len</span>(h.allArenas)+<span class="number">1</span>]</span><br><span class="line">		h.allArenas[<span class="built_in">len</span>(h.allArenas)<span class="number">-1</span>] = ri</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Store atomically just in case an object from the</span></span><br><span class="line">		<span class="comment">// new heap arena becomes visible before the heap lock</span></span><br><span class="line">		<span class="comment">// is released (which shouldn&#x27;t happen, but there&#x27;s</span></span><br><span class="line">		<span class="comment">// little downside to this).</span></span><br><span class="line">		atomic.StorepNoWB(unsafe.Pointer(&amp;l2[ri.l2()]), unsafe.Pointer(r))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Tell the race detector about the new heap memory.</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racemapshadow(v, size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sysReserve-mmap系统调用"><a href="#sysReserve-mmap系统调用" class="headerlink" title="sysReserve-mmap系统调用"></a>sysReserve-mmap系统调用</h4><p>在Linux系统上调用mmap函数</p>
<p><strong>Mmap</strong>：Mmap是内存映射文件的缩写。它是一种无需调用系统调用就能读写文件的方式。操作系统预留了程序虚拟地址的一块，直接 “映射 “到文件中的一块。因此，如果程序从该部分地址空间读取数据，就会获得驻留在文件相应部分的数据。如果文件的那部分数据恰好驻留在缓冲区缓存中，那么在第一次访问时，只需将映射后的块的虚拟地址映射到相应的缓冲区缓存页的物理地址即可，以后不会再调用系统调用或其他陷阱。如果文件数据不在缓冲区缓存中，访问映射区域会产生一个页面故障，提示内核去从磁盘中获取相应的数据</p>
<p>分配、释放内存在不同的平台 (linux&#x2F;win&#x2F;bsd) 有差异，所以 Go 先对这些基础函数进行了封装，如Linux在runtime&#x2F;mem-linux.go中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysReserve</span><span class="params">(v unsafe.Pointer, n <span class="type">uintptr</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	p, err := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mmap is used to do low-level memory allocation via mmap. Don&#x27;t allow stack</span></span><br><span class="line"><span class="comment">// splits, since this function (used by sysAlloc) is called in a lot of low-level</span></span><br><span class="line"><span class="comment">// parts of the runtime and callers often assume it won&#x27;t acquire any locks.</span></span><br><span class="line"><span class="comment">// go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mmap</span><span class="params">(addr unsafe.Pointer, n <span class="type">uintptr</span>, prot, flags, fd <span class="type">int32</span>, off <span class="type">uint32</span>)</span></span> (unsafe.Pointer, <span class="type">int</span>) &#123;</span><br><span class="line">	args := <span class="keyword">struct</span> &#123;</span><br><span class="line">		addr            unsafe.Pointer</span><br><span class="line">		n               <span class="type">uintptr</span></span><br><span class="line">		prot, flags, fd <span class="type">int32</span></span><br><span class="line">		off             <span class="type">uint32</span></span><br><span class="line">		ret1            unsafe.Pointer</span><br><span class="line">		ret2            <span class="type">int</span></span><br><span class="line">	&#125;&#123;addr, n, prot, flags, fd, off, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">	libcCall(unsafe.Pointer(funcPC(mmap_trampoline)), unsafe.Pointer(&amp;args))</span><br><span class="line">	<span class="keyword">return</span> args.ret1, args.ret2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mmap_trampoline</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>另外，runtime还提供了sysReserve，sysUnused，sysUsed，sysFree，sysFault，sysMap一系列方法，将内存在不同的下列四种状态间切换</p>
<ul>
<li>None:内存没有被保留或者映射，是地址空间的默认状态</li>
<li>Reserve:运行时持有该地址空间，但是访问该内存会导致错误</li>
<li>Prepare:内存被保留</li>
<li>Ready:可以被安全访问</li>
</ul>
<p><img src="/images/golang-memory4.jpg" alt="image"></p>
<p>finish</p>
<p>至此，内存申请的整个流程结束。</p>
<p>本文引自<a href="https://www.spider1998.com/2021/12/29/Golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">这里</a></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Golang/">Golang</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://luckymrwang.github.io/2022/05/08/Golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" data-title="Golang内存分配源码解析 | iBlog" data-tsina="iuckymrwang" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2022/05/10/Calico引入eBPF/" title="Calico引入eBPF">
  <strong>上一篇：</strong><br/>
  <span>
  Calico引入eBPF</span>
</a>
</div>


<div class="next">
<a href="/2022/05/08/Kubernetes-内存资源限制实战/"  title="Kubernetes 内存资源限制实战">
 <strong>下一篇：</strong><br/> 
 <span>Kubernetes 内存资源限制实战
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2022/05/08/Golang内存分配源码解析/" data-title="Golang内存分配源码解析" data-url="https://luckymrwang.github.io/2022/05/08/Golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">Golang内存分配整体架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#makeslice"><span class="toc-number">2.</span> <span class="toc-text">makeslice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96-mallocinit"><span class="toc-number">3.</span> <span class="toc-text">内存初始化-mallocinit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mcentral%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">mcentral初始化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mallocgc-%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7"><span class="toc-number">3.2.</span> <span class="toc-text">mallocgc-内存申请</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">什么是内存对齐？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runtime-nextFreeFast-%E5%B0%9D%E8%AF%95%E4%BB%8E%E7%BC%93%E5%AD%98%E4%B8%AD%E5%BF%AB%E9%80%9F%E5%88%86%E9%85%8D"><span class="toc-number">3.4.</span> <span class="toc-text">runtime.nextFreeFast-尝试从缓存中快速分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mcache-nextFree-%E7%94%B3%E8%AF%B7%E6%96%B0%E7%9A%84span"><span class="toc-number">3.5.</span> <span class="toc-text">mcache.nextFree-申请新的span</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mcache-refill-%E5%90%91mcentral%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98"><span class="toc-number">3.6.</span> <span class="toc-text">mcache.refill-向mcentral申请内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mcentral-cacheSpan-%E5%90%91mcentral%E7%94%B3%E8%AF%B7span"><span class="toc-number">3.7.</span> <span class="toc-text">mcentral.cacheSpan-向mcentral申请span</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mcentral-grow-%E5%90%91heap%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98"><span class="toc-number">3.8.</span> <span class="toc-text">mcentral.grow-向heap申请内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mcache-allocLarge-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D"><span class="toc-number">3.9.</span> <span class="toc-text">mcache.allocLarge-大对象分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mheap%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B"><span class="toc-number">3.10.</span> <span class="toc-text">mheap分配流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#alloc"><span class="toc-number">3.10.1.</span> <span class="toc-text">alloc</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#allocSpan"><span class="toc-number">3.11.</span> <span class="toc-text">allocSpan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#grow-%E5%90%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98"><span class="toc-number">3.12.</span> <span class="toc-text">grow-向操作系统申请内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sysAlloc"><span class="toc-number">3.13.</span> <span class="toc-text">sysAlloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sysReserve-mmap%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.14.</span> <span class="toc-text">sysReserve-mmap系统调用</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/example/" title="example">example<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Go/" title="Go">Go<sup>46</sup></a></li>
			
		
			
				<li><a href="/tags/Linux/" title="Linux">Linux<sup>35</sup></a></li>
			
		
			
				<li><a href="/tags/PHP/" title="PHP">PHP<sup>19</sup></a></li>
			
		
			
				<li><a href="/tags/Kubernetes/" title="Kubernetes">Kubernetes<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/Golang/" title="Golang">Golang<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Mac/" title="Mac">Mac<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/jQuery/" title="jQuery">jQuery<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Apache/" title="Apache">Apache<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/MySQL/" title="MySQL">MySQL<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/CentOS/" title="CentOS">CentOS<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Go笔记/" title="Go笔记">Go笔记<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Nginx/" title="Nginx">Nginx<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Docker/" title="Docker">Docker<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/eBPF/" title="eBPF">eBPF<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Git/" title="Git">Git<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/DataTables/" title="DataTables">DataTables<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/GoExample/" title="GoExample">GoExample<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/监控/" title="监控">监控<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/JS/" title="JS">JS<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>3</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Just do it <br/>
			</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/luckymrwang" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		
		<a href="/about" target="_blank" title="luckymrwang">luckymrwang</a>
		

		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"luckymrwang"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-68490584-1', 'auto');  
ga('send', 'pageview');
</script>





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
